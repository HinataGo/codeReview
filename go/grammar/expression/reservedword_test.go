package expression

import (
	"fmt"
	"testing"
)

// 组合的运算符 = 都在右边 ,例如 <= >=  ./=  %=  &=  >>= <<= &^= := != |= ^= *= += -=
// &^ (bit clear)
// ^a (一元)按位取反     				011    	 100
// a^b (二元) 同只有一个1 时为1			011^001	 010
// a&b 同一为1						011^001	 001
// a<<b 位左移, 即a 后增加 b 个 0   	001<<2   100
// a>>b 位右移, a向右移动b位    		100>>2   001

/**
  1个字节=8个二进制位,每种数据类型占用的字节数都不一样
  注意位操作千万不要越界了，如某个类型占8个bit位，偏移时候不要超过这个范围
*/
func TestOp(t *testing.T) {
	// 按位清零 b中有1的部分 对 a中对应位置的数 一律置 0 (可以说是拿b去对a的部分位置清零,如果a对应位置本来就是0 则那个位置无需变动)
	// 数据输入时为十进制,底层转换成二进制后再计算的
	a := 11     // 0000	1011
	b := 6      // 0000 0110
	c := a &^ b // 0000	1001
	fmt.Printf("%b \n", c)

	// ++ -- 首先这两个必须后置 即 a-- a++
	// 其次,不是运算符了,是独立语句,不能用于表达式
	// arr[i++]   if a++{}  都是错误的
	// *p++ ---> (*P) ++ 相当于指针的自增,这是允许的
	// 表达式通常是求值的,可以作为 右值, 参数使用
	// 表达式可以作为语句使用,反之不可以

	// 内存地址和指针
}
